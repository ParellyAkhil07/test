import org.junit.Test;
import static org.junit.Assert.assertEquals;
import java.util.Stack;

public class Calculator {

    // Method to evaluate the expression
    public static double evaluate(String expression) {
        expression = expression.replaceAll(" ", "");
        Stack<Integer> parensIndices = new Stack<>();
        StringBuilder storage = new StringBuilder();
        Operators operators = new Operators();

        for (int i = 0; i < expression.length(); i++) {
            char charAt = expression.charAt(i);
            if (charAt == '(') {
                parensIndices.push(i);
            } else if (charAt == ')') {
                int start = parensIndices.pop() + 1;
                double total = calculate(expression.substring(start, i), operators);
                storage.setLength(start - 1);
                storage.append(total);
            } else {
                storage.append(charAt);
            }

            if (operators.isOperator(charAt)) {
                operators.addOperator(charAt, i);
            }
        }

        return calculate(storage.toString(), operators);
    }

    // Method to calculate the expression without parentheses
    private static double calculate(String innerExpression, Operators operators) {
        StringBuilder newExpr = new StringBuilder(innerExpression);
        double total = 0;

        operators.resetOperators(innerExpression);

        while (!operators.isEmpty('*')) {
            int opIndex = operators.popOperator('*');
            double prev = Character.getNumericValue(newExpr.charAt(opIndex - 1));
            double nxt = Character.getNumericValue(newExpr.charAt(opIndex + 1));
            total = prev * nxt;
            newExpr.replace(opIndex - 1, opIndex + 2, String.valueOf(total));
        }

        while (!operators.isEmpty('/')) {
            int opIndex = operators.popOperator('/');
            double prev = Character.getNumericValue(newExpr.charAt(opIndex - 1));
            double nxt = Character.getNumericValue(newExpr.charAt(opIndex + 1));
            total = prev / nxt;
            newExpr.replace(opIndex - 1, opIndex + 2, String.valueOf(total));
        }

        while (!operators.isEmpty('-')) {
            int opIndex = operators.popOperator('-');
            double prev = Character.getNumericValue(newExpr.charAt(opIndex - 1));
            double nxt = Character.getNumericValue(newExpr.charAt(opIndex + 1));
            total = prev - nxt;
            newExpr.replace(opIndex - 1, opIndex + 2, String.valueOf(total));
        }

        while (!operators.isEmpty('+')) {
            int opIndex = operators.popOperator('+');
            double prev = Character.getNumericValue(newExpr.charAt(opIndex - 1));
            double nxt = Character.getNumericValue(newExpr.charAt(opIndex + 1));
            total = prev + nxt;
            newExpr.replace(opIndex - 1, opIndex + 2, String.valueOf(total));
        }

        return total;
    }

    // Helper class to manage operators and their indices
    static class Operators {
        private Stack<Integer> multiply = new Stack<>();
        private Stack<Integer> divide = new Stack<>();
        private Stack<Integer> add = new Stack<>();
        private Stack<Integer> subtract = new Stack<>();

        boolean isOperator(char c) {
            return c == '*' || c == '/' || c == '+' || c == '-';
        }

        void addOperator(char operator, int index) {
            switch (operator) {
                case '*': multiply.push(index); break;
                case '/': divide.push(index); break;
                case '+': add.push(index); break;
                case '-': subtract.push(index); break;
            }
        }

        boolean isEmpty(char operator) {
            switch (operator) {
                case '*': return multiply.isEmpty();
                case '/': return divide.isEmpty();
                case '+': return add.isEmpty();
                case '-': return subtract.isEmpty();
                default: return true;
            }
        }

        int popOperator(char operator) {
            switch (operator) {
                case '*': return multiply.pop();
                case '/': return divide.pop();
                case '+': return add.pop();
                case '-': return subtract.pop();
                default: throw new IllegalArgumentException("Invalid operator");
            }
        }

        void resetOperators(String expression) {
            multiply.clear();
            divide.clear();
            add.clear();
            subtract.clear();
            for (int i = 0; i < expression.length(); i++) {
                char charAt = expression.charAt(i);
                if (isOperator(charAt)) {
                    addOperator(charAt, i);
                }
            }
        }
    }

    // Unit tests
    public static class Testing {

        @Test
        public void testNoParens() {
            assertEquals(7.0, Calculator.evaluate("1 + 3 * 2"), 0.001);
        }

        @Test
        public void testSingleParens() {
            assertEquals(16.0, Calculator.evaluate("(1 + 7) * 2"), 0.001);
        }

        @Test
        public void testOperationsOrder() {
            assertEquals(29.0, Calculator.evaluate("4 * (1 + 7) - 3"), 0.001);
        }

        @Test
        public void testLongParens() {
            assertEquals(-6.0, Calculator.evaluate("(4 - 7 - 1) * 3"), 0.001);
        }

        @Test
        public void testDecimals() {
            assertEquals(6.25, Calculator.evaluate("(1.2 + 1.3) * 2.5"), 0.001);
        }
    }

    public static void main(String[] args) {
        org.junit.runner.JUnitCore.main("Calculator$Testing");
    }
}